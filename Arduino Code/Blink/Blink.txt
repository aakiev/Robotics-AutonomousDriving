

//- **Mean (`mu`)**:
//  - 5 cm: \(\mu \approx 5.04\)
//  - 20 cm: \(\mu \approx 20.30\)
//  - 40 cm: \(\mu \approx 38.25\)
//  - 65 cm: \(\mu \approx 61.79\)
//  - 100 cm: \(\mu \approx 95.49\)
//  - 150 cm: \(\mu \approx 142.54\)

//- **Variance (`sigma^2`)**:
//  - 5 cm: \(\sigma^2 \approx 0.0028\)
//  - 20 cm: \(\sigma^2 \approx 0.0201\)
//  - 40 cm: \(\sigma^2 \approx 0.1103\)
//  - 65 cm: \(\sigma^2 \approx 0.1178\)
//  - 100 cm: \(\sigma^2 \approx 0.1803\)
//  - 150 cm: \(\sigma^2 \approx 0.7711\)


#include <Servo.h>
Servo myservo;
int pos = 0;    // Servomotor auf 0 Grad

long duration;  // Daten f√ºr Ultraschallsensor
float distancecm;
int trigPin = 7;
int echoPin = 8;

// Gaussian filter parameters
const int numMeasurements = 5; // Number of measurements to smooth
float measurements[numMeasurements];
int currentMeasurement = 0;

// Lookup table for mu and sigma2 values
struct GaussianParams {
    float mu;
    float sigma2;
};

GaussianParams getGaussianParams(float distance) {
    if (distance <= 5) {
        return {5.04, 0.0028}; // Values for 5 cm
    } else if (distance <= 20) {
        return {20.30, 0.0201}; // Values for 20 cm
    } else if (distance <= 40) {
        return {38.25, 0.1103}; // Values for 40 cm
    } else if (distance <= 65) {
        return {61.79, 0.1178}; // Values for 65 cm
    } else if (distance <= 100) {
        return {95.49, 0.1803}; // Values for 100 cm
    } else {
        return {142.54, 0.7711}; // Values for 150 cm
    }
}

// Gaussian function
float gaussian(float mu, float sigma2, float x) {
    float prob = 1.0 / sqrt(2.0 * PI * sigma2) * exp(-0.5 * pow((x - mu), 2.0) / sigma2);
    return prob;
}

// Apply Gaussian filter to measurements
float applyGaussianFilter(float* data, int size, float mu, float sigma2) {
    float smoothedValue = 0;
    for (int i = 0; i < size; i++) {
        smoothedValue += gaussian(mu, sigma2, data[i]);
    }
    return smoothedValue / size;
}

void setup() {
    pinMode(trigPin, OUTPUT); // Setup welcher Pin Input und welcher Output ist
    pinMode(echoPin, INPUT);
    Serial.begin(9600);       // Geschwindigkeit der Ausgabe

    myservo.attach(3);        // 3 Pins am Servo (Wo ich den anspreche)
    myservo.write(0);         // positioniere dich auf 0 grad
    delay(1000);
}

void loop() {
    // Take a measurement
    digitalWrite(trigPin, LOW);
    delayMicroseconds(2);

    // Trigger the sensor with a 10 microseconds HIGH pulse
    digitalWrite(trigPin, HIGH);
    delayMicroseconds(10);
    digitalWrite(trigPin, LOW);

    // Obtain length of HIGH pulse in
    duration = pulseIn(echoPin, HIGH);

    // Calculate distance in cm
    distancecm = duration * 0.034 / 2.0;

    // Store the measurement in the array
    measurements[currentMeasurement] = distancecm;
    currentMeasurement = (currentMeasurement + 1) % numMeasurements;

    // Get Gaussian parameters based on the current distance
    GaussianParams params = getGaussianParams(distancecm);

    // Apply Gaussian filter
    float smoothedDistance = applyGaussianFilter(measurements, numMeasurements, params.mu, params.sigma2);

    // Control the servo based on the smoothed distance
    if (smoothedDistance <= 5) {
        myservo.write(0);
    } else if (smoothedDistance > 5 && smoothedDistance <= 30) {
        myservo.write((smoothedDistance - 5) * (180.0 / (30 - 5)));
    } else {
        myservo.write(180);
    }

    // Output the smoothed distance
    Serial.print("Smoothed Distance: ");
    Serial.println(smoothedDistance);
    delay(100);
}
